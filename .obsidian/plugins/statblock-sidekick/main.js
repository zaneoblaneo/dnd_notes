/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => StatblockSidekick
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// statblocks/components.ts
var ChallengeRating = class {
  constructor(value) {
    this.value = value;
  }
  static parse(crInput) {
    const crString = typeof crInput === "number" ? crInput.toString() : crInput;
    if (!crString)
      return null;
    let value;
    if (crString.includes("/")) {
      const [numerator, denominator] = crString.split("/").map(Number);
      value = numerator / denominator;
    } else {
      value = Number(crString);
      if (isNaN(value))
        return null;
    }
    return new ChallengeRating(value);
  }
  isSuitable(maxCr = 0.5) {
    return this.value <= maxCr;
  }
};
var HitDice = class {
  constructor(numDice, dieType, bonus) {
    this.numDice = numDice;
    this.dieType = dieType;
    this.bonus = bonus;
  }
  static parse(hitDiceString) {
    const regex = /^(\d+)d(\d+)(?:\s*([+-]\s*\d+))?$/;
    const match = hitDiceString.match(regex);
    if (!match)
      return null;
    const bonus = parseInt((match[3] || "0").replace(/\s/g, ""), 10);
    return new HitDice(parseInt(match[1], 10), parseInt(match[2], 10), bonus);
  }
  increment(conModifier) {
    this.numDice += 1;
    this.bonus += conModifier;
  }
  toString() {
    return `${this.numDice}d${this.dieType}${this.bonus >= 0 ? "+" : ""}${this.bonus}`;
  }
};
var Abilities = class {
  constructor(strength, dexterity, constitution, intelligence, wisdom, charisma) {
    this.strength = strength;
    this.dexterity = dexterity;
    this.constitution = constitution;
    this.intelligence = intelligence;
    this.wisdom = wisdom;
    this.charisma = charisma;
  }
  static fromArray(abilityArray) {
    return new Abilities(...abilityArray);
  }
  /**
   * Calculate the modifier for a given ability score.
   * This method is public and static, allowing it to be used without an instance of Abilities.
   * @param score - The ability score from which to calculate the modifier.
   * @returns The calculated modifier.
   */
  static calculateModifier(score) {
    return Math.floor((score - 10) / 2);
  }
  static calculateModifiers(abilities) {
    return Object.fromEntries(
      Object.entries(abilities).map(([key, value]) => [key, Abilities.calculateModifier(value)])
    );
  }
  static calculateModDiff(oldMods, newMods) {
    const modDiffs = { ...new Abilities(0, 0, 0, 0, 0, 0) };
    for (const ability in oldMods) {
      if (ability in newMods) {
        modDiffs[ability] = newMods[ability] - oldMods[ability];
      }
    }
    return modDiffs;
  }
};
var Proficiency = class {
  static calculatePB(level) {
    return Math.ceil(1 + level / 4);
  }
};
var Attack = class {
  constructor(trait) {
    this.finesseWeapons = [
      "dagger",
      "rapier",
      "shortsword",
      "dart",
      "scimitar",
      "whip"
    ];
    this.martialWeapons = [
      "battleaxe",
      "flail",
      "glaive",
      "greataxe",
      "greatsword",
      "halberd",
      "lance",
      "longsword",
      "maul",
      "morningstar",
      "pike",
      "rapier",
      "scimitar",
      "shortsword",
      "trident",
      "war pick",
      "warhammer",
      "whip",
      "blowgun",
      "hand crossbow",
      "heavy crossbow",
      "longbow",
      "net"
    ];
    this.simpleWeapons = [
      "club",
      "dagger",
      "greatclub",
      "handaxe",
      "javelin",
      "light hammer",
      "mace",
      "quarterstaff",
      "sickle",
      "spear",
      "light crossbow",
      "dart",
      "shortbow",
      "sling"
    ];
    this.name = trait.name;
    this.desc = trait.desc;
    this.parseDescription();
    this.isFinesseWeapon = this.finesseWeapons.includes(this.name.toLowerCase());
    this.isMartialWeapon = this.martialWeapons.includes(this.name.toLowerCase());
    this.isSimpleWeapon = this.simpleWeapons.includes(this.name.toLowerCase());
  }
  parseDescription() {
    const attackTypeMatch = this.desc.match(/^(Melee\s+or\s+Ranged|Melee|Ranged)/i);
    const toHitMatch = this.desc.match(/([+-]?\d+)\s*to\s*hit/i);
    const reachMatch = this.desc.match(/reach\s*(\d+)\s*ft\./i);
    const rangeMatch = this.desc.match(/range\s*(\d+)\/(\d+)\s*ft\./i);
    const targetMatch = this.desc.match(/one\s(\d+|target)/i);
    const hitKeywordMatch = this.desc.match(/Hit:/i);
    const averageDamageMatch = this.desc.match(/\d+(?=\s*\()/);
    const numDiceMatch = this.desc.match(/\d+(?=d)/);
    const diceTypeMatch = this.desc.match(/d(\d+)/);
    const damageModMatch = this.desc.match(/[+-]\s*\d+(?=\))/);
    const damageTypeMatch = this.desc.match(/\w+(?=\s+damage)/i);
    if (attackTypeMatch) {
      this.isAttack = true;
      this.isMeleeWeapon = attackTypeMatch[1] === "Melee" || attackTypeMatch[1] === "Melee or Ranged";
      this.isRangedWeapon = attackTypeMatch[1] === "Ranged" || attackTypeMatch[1] === "Melee or Ranged";
    } else {
      this.isAttack = false;
    }
    if (toHitMatch) {
      this.toHit = parseInt(toHitMatch[1], 10);
    }
    if (reachMatch) {
      this.reach = parseInt(reachMatch[1], 10);
    }
    if (rangeMatch) {
      this.range = {
        normal: parseInt(rangeMatch[1], 10),
        long: parseInt(rangeMatch[2], 10)
      };
    }
    if (targetMatch) {
      this.target = targetMatch[1] === "target" ? 1 : parseInt(targetMatch[1], 10);
    }
    if (hitKeywordMatch) {
      if (averageDamageMatch) {
        this.averageDamage = parseInt(averageDamageMatch[0], 10);
      }
      if (numDiceMatch) {
        this.numDice = parseInt(numDiceMatch[0], 10);
      }
      if (diceTypeMatch) {
        this.diceType = parseInt(diceTypeMatch[1], 10);
      }
      if (damageModMatch) {
        const sign = damageModMatch[0].charAt(0);
        const value = parseInt(damageModMatch[0].slice(1), 10);
        this.damageMod = sign === "+" ? value : -value;
      } else {
        this.damageMod = 0;
      }
      if (damageTypeMatch) {
        this.damageType = damageTypeMatch[0];
      }
    }
  }
  constructDescription() {
    let desc = "";
    if (this.isMeleeWeapon && this.isRangedWeapon) {
      desc += "Melee or Ranged ";
    } else if (this.isMeleeWeapon) {
      desc += "Melee ";
    } else if (this.isRangedWeapon) {
      desc += "Ranged ";
    }
    if (this.isAttack && this.toHit !== void 0) {
      desc += `Weapon Attack: ${this.toHit >= 0 ? "+" : "-"}${this.toHit} to hit`;
    }
    if (this.reach && this.range) {
      desc += `, reach ${this.reach} ft. or range ${this.range.normal}/${this.range.long} ft.`;
    } else {
      if (this.reach) {
        desc += `, reach ${this.reach} ft.`;
      }
      if (this.range) {
        desc += `, range ${this.range.normal}/${this.range.long} ft.`;
      }
    }
    if (this.isAttack && this.target !== void 0) {
      const targetText = this.target === 1 ? "one target" : `${this.target} targets`;
      desc += `, ${targetText}. `;
    }
    if (this.numDice && this.diceType && this.damageType) {
      desc += "Hit: ";
      if (this.averageDamage) {
        desc += `${this.averageDamage} (`;
      }
      desc += `${this.numDice}d${this.diceType}`;
      if (this.damageMod !== void 0) {
        desc += `${this.damageMod >= 0 ? " + " : " - "}${Math.abs(this.damageMod)}`;
      }
      if (this.averageDamage) {
        desc += ")";
      }
      desc += ` ${this.damageType} damage`;
    }
    return desc.trim();
  }
  getRelevantAbility(abilities) {
    if (this.isMeleeWeapon && !this.isFinesseWeapon) {
      return "strength";
    } else if (this.isRangedWeapon) {
      return "dexterity";
    } else if (this.isFinesseWeapon) {
      const strengthModifier = Abilities.calculateModifier(abilities.strength);
      const dexterityModifier = Abilities.calculateModifier(abilities.dexterity);
      return strengthModifier >= dexterityModifier ? "strength" : "dexterity";
    }
    throw new Error("Invalid attack type");
  }
  calculateExpectedValues(abilities, proficiencyBonus) {
    const relevantAbility = this.getRelevantAbility(abilities);
    const abilityMod = Abilities.calculateModifier(abilities[relevantAbility]);
    const expectedToHit = abilityMod + proficiencyBonus;
    const expectedDamageMod = abilityMod;
    return { toHit: expectedToHit, damageMod: expectedDamageMod };
  }
};

// modals/modals.ts
var import_obsidian = require("obsidian");

// sidekicks/classes.ts
var Expert = class {
  constructor() {
    this.name = "Expert";
    this.desc = "The Expert is a master of certain tasks or knowledge, favoring cunning over brawn.\nIt might be a scout, a musician, a librarian, a clever street kid, a wily merchant, or a burglar.";
    this.featuresByLevel = {
      1: [
        {
          name: "Saving Throw Proficiency",
          desc: "The sidekick gains proficiency in one saving throw of your choice",
          options: [
            { name: "Dexterity" },
            { name: "Intelligence" },
            { name: "Charisma" }
          ],
          nbChoices: 1
        },
        {
          name: "Skill Proficiencies",
          desc: "The sidekick gains proficiency in five skills of your choice.",
          options: [
            { name: "Acrobatics" },
            { name: "Animal Handling" },
            { name: "Arcana" },
            { name: "Athletics" },
            { name: "Deception" },
            { name: "History" },
            { name: "Insight" },
            { name: "Intimidation" },
            { name: "Investigation" },
            { name: "Medicine" },
            { name: "Nature" },
            { name: "Perception" },
            { name: "Performance" },
            { name: "Persuasion" },
            { name: "Religion" },
            { name: "Sleight of Hand" },
            { name: "Stealth" },
            { name: "Survival" }
          ],
          nbChoices: 5
        },
        {
          name: "Armor Proficiency",
          desc: "light armor"
        },
        {
          name: "Weapon Proficiency",
          desc: "all simple weapons",
          conditions: ["humanoid", "simple weapon", "martial weapon"]
        },
        {
          name: "Tool Proficiencies",
          desc: "",
          conditions: ["humanoid", "simple weapon", "martial weapon"],
          options: [
            { "name": "Alchemist's supplies" },
            { "name": "Brewer's supplies" },
            { "name": "Calligrapher's supplies" },
            { "name": "Carpenter's tools" },
            { "name": "Cartographer's tools" },
            { "name": "Cobbler's tools" },
            { "name": "Cook's utensils" },
            { "name": "Disguise kit" },
            { "name": "Forgery kit" },
            { "name": "Glassblower's tools" },
            { "name": "Herbalism kit" },
            { "name": "Jeweler's tools" },
            { "name": "Leatherworker's tools" },
            { "name": "Mason's tools" },
            { "name": "Navigator's tools" },
            { "name": "Painter's supplies" },
            { "name": "Poisoner's kit" },
            { "name": "Potter's tools" },
            { "name": "Smith's tools" },
            { "name": "Tinker's tools" },
            { "name": "Thieves' tools" },
            { "name": "Weaver's tools" },
            { "name": "Woodcarver's tools" }
          ],
          nbChoices: 2
        },
        {
          name: "Helpful",
          desc: "The sidekick can take the Help action as a bonus action.",
          category: "bonus_actions"
        }
      ],
      2: [
        {
          name: "Cunning Action",
          desc: "On its turn in combat, the sidekick can take the Dash, Disengage, or Hide action as a bonus action.",
          category: "bonus_actions"
        }
      ],
      3: [
        {
          name: "Expertise",
          desc: "Choose two of the sidekick's skill proficiencies. The sidekick's proficiency bonus is doubled for any ability check it makes that uses any of the chosen proficiencies.",
          options: [
            { name: "Will be determined based on the sidekick's skill proficiencies" }
          ],
          nbChoices: 2
        }
      ],
      4: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      6: [
        {
          name: "Helpful",
          desc: "The sidekick can take the Help action as a bonus action. When using this feature to aid an ally in attacking a creature, that target can be up to 30 feet away from the sidekick, and the sidekick can deal an extra 2d6 damage to it the next time the sidekick hits it with an attack roll before the end of the current turn. The extra damage is the same type of damage dealt by the attack.",
          category: "bonus_actions"
        }
      ],
      7: [
        {
          name: "Evasion",
          desc: "When the sidekick is subjected to an effect that allows it to make a Dexterity saving throw to take only half damage, it instead takes no damage if it succeeds on the saving throw, and only half damage if it failed. The sidekick doesn't benefit from this feature while incapacitated."
        }
      ],
      8: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      10: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      11: [
        {
          name: "Inspiring Help",
          desc: "When the sidekick takes the Help action, the creature who receives the help also gains a 1d6 bonus to the d20 roll. If that roll is an attack roll, the creature can forgo adding the bonus to it, and then if the attack hits, the creature can add the bonus to the attack's damage roll against one target."
        }
      ],
      12: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      14: [
        {
          name: "Reliable Talent",
          desc: "Whenever the sidekick makes an ability check that includes its whole proficiency bonus, it can treat a d20 roll of 9 or lower as a 10."
        }
      ],
      15: [
        {
          name: "Expertise",
          desc: "Choose two of the sidekick's skill proficiencies. The sidekick's proficiency bonus is doubled for any ability check it makes that uses any of the chosen proficiencies.",
          options: [
            { name: "Will be determined based on the sidekick's skill proficiencies" }
          ],
          nbChoices: 2
        }
      ],
      16: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      18: [
        {
          name: "Saving Throw Proficiency",
          desc: "Sharp Mind: The sidekick gains proficiency in one saving throw of your choice.",
          options: [
            { name: "Intelligence" },
            { name: "Wiscom" },
            { name: "Charisma" }
          ],
          nbChoices: 1
        }
      ],
      19: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      20: [
        {
          name: "Inspiring Help",
          desc: "When the sidekick takes the Help action, the creature who receives the help also gains a 2d6 bonus to the d20 roll. If that roll is an attack roll, the creature can forgo adding the bonus to it, and then if the attack hits, the creature can add the bonus to the attack's damage roll against one target."
        }
      ]
    };
  }
};
var Spellcaster = class {
  constructor() {
    this.name = "Spellcaster";
    this.desc = "A sidekick who becomes a Spellcaster walks the paths of magic.\nThe sidekick might be a hedge wizard, a priest, a soothsayer, a magical performer, or a person with magic in their veins.";
    this.featuresByLevel = {
      1: [
        {
          name: "Saving Throw Proficiency",
          desc: "The sidekick gains gain proficiency in one saving throw of your choice",
          options: [
            { name: "Wisdom" },
            { name: "Intelligence" },
            { name: "Charisma" }
          ],
          nbChoices: 1
        },
        {
          name: "Skill Proficiencies",
          desc: "The sidekick gains proficiency in five skills of your choice.",
          options: [
            { name: "Arcana" },
            { name: "History" },
            { name: "Insight" },
            { name: "Investigation" },
            { name: "Medicine" },
            { name: "Performance" },
            { name: "Persuasion" },
            { name: "Religion" }
          ],
          nbChoices: 2
        },
        {
          name: "Armor Proficiency",
          desc: "light armor"
        },
        {
          name: "Weapon Proficiency",
          desc: "all simple weapons",
          conditions: ["humanoid", "simple weapon", "martial weapon"]
        },
        {
          name: "Spellcaster Role",
          desc: "The sidekick gains the ability to cast spells. Choose the Spellcaster's role: Mage, Healer, or Prodigy. This choice determines the spell list and spellcasting ability used by the sidekick.",
          options: [
            {
              name: "Mage",
              desc: "Spell List: Wizard - Spellcasting Ability: Intelligence"
            },
            {
              name: "Healer",
              desc: "Spell Lists: Cleric and Druid - Spellcasting Ability: Wisdom"
            },
            {
              name: "Prodigy",
              desc: "Spell Lists: Bard and Warlock - Spellcasting Ability: Charisma"
            }
          ],
          nbChoices: 1
        }
      ],
      4: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      6: [
        {
          name: "Potent Cantrips",
          desc: "The sidekick can add its spellcasting ability modifier to the damage it deals with any cantrip."
        }
      ],
      8: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      12: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      14: [
        {
          name: "School of Magic for Empowered Spells",
          desc: "Choose one school of magic. Whenever the sidekick casts a spell of that school by expending a spell slot, the sidekick can add its spellcasting ability modifier to the spell's damage roll or healing roll, if any.",
          options: [
            { name: "Abjuration" },
            { name: "Conjuration" },
            { name: "Divination" },
            { name: "Enchantment" },
            { name: "Evocation" },
            { name: "Illusion" },
            { name: "Necromancy" },
            { name: "Transmutation" }
          ],
          nbChoices: 1
        }
      ],
      16: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      18: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      20: [
        {
          name: "Focused Casting",
          desc: "Taking damage can't break the sidekick's concentration on a spell."
        }
      ]
    };
  }
};
var Warrior = class {
  constructor() {
    this.name = "Warrior";
    this.desc = "A Warrior sidekick grows in martial prowess as it fights by your side.\nIt might be a soldier, a town guard, a battle-trained beast, or any other creature honed for combat.";
    this.featuresByLevel = {
      1: [
        {
          name: "Saving Throw Proficiency",
          desc: "The sidekick gains proficiency in one saving throw of your choice",
          options: [
            { name: "Strength" },
            { name: "Dexterity" },
            { name: "Constitution" }
          ],
          nbChoices: 1
        },
        {
          name: "Skill Proficiencies",
          desc: "The sidekick gains proficiency in two skills of your choice",
          options: [
            { name: "Acrobatics" },
            { name: "Animal Handling" },
            { name: "Athletics" },
            { name: "Intimidation" },
            { name: "Nature" },
            { name: "Perception" },
            { name: "Survival" }
          ],
          nbChoices: 2
        },
        {
          name: "Armor Proficiency",
          desc: "all armor"
        },
        {
          name: "Weapon Proficiencies",
          desc: "all simple and martial weapons",
          conditions: ["humanoid", "simple weapon", "martial weapon"]
        },
        {
          name: "Shield Proficiency",
          desc: "shields",
          conditions: ["humanoid", "simple weapon", "martial weapon"]
        },
        {
          name: "Martial Role",
          desc: "Each warrior focuses on offense or defense in their training. Choose one of the following options:",
          options: [
            {
              name: "Attacker",
              desc: "The sidekick gains a + 2 bonus to all attack rolls (already included)."
            },
            {
              name: "Defender",
              desc: "The sidekick can use its reaction to impose disadvantage on the attack roll of a creature within 5 feet of it whose target isn't the sidekick, provided the sidekick can see the attacker.",
              category: "reactions"
            }
          ],
          nbChoices: 1
        }
      ],
      2: [
        {
          name: "Second Wind",
          desc: "Once per short or long rest, the sidekick can use a bonus action on its turn to regain hit points equal to 1d10 + its level in this class.",
          category: "bonus_actions"
        }
      ],
      3: [
        {
          name: "Improved Critical",
          desc: "The sidekick's attack rolls score a critical hit on a roll of 19 or 20 on the d20."
        }
      ],
      4: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      6: [
        {
          name: "Extra Attack",
          desc: "The sidekick can attack twice, instead of once, whenever it takes the Attack action on its turn. If the sidekick has the Multiattack action, it can use Extra Attack or Multiattack on a turn, not both."
        }
      ],
      7: [
        {
          name: "Battle Readiness",
          desc: "The sidekick has advantage on initiative rolls."
        }
      ],
      8: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      10: [
        {
          name: "Improved Defense",
          desc: "The sidekick's Armor Class increases by 1 (already iuncluded)."
        }
      ],
      11: [
        {
          name: "Indomitable",
          desc: "Once per long rest, the sidekick can reroll a saving throw that it fails, but it must use the new roll."
        }
      ],
      12: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      14: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      15: [
        {
          name: "Extra Attack",
          desc: "The sidekick can attack three times, instead of once, whenever it takes the Attack action on its turn. If the sidekick has the Multiattack action, it can use Extra Attack or Multiattack on a turn, not both."
        }
      ],
      16: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      18: [
        {
          name: "Indomitable",
          desc: "Twice per long rest, the sidekick can reroll a saving throw that it fails, but it must use the new roll."
        }
      ],
      19: [
        {
          name: "Ability Score Improvement",
          desc: "The sidekick increases one ability score of your choice by 2, or the sidekick increases two ability scores of your choice by 1. The sidekick can't increase an ability score above 20 using this feature.",
          options: [
            { name: "Will be determined based on the sidekick's current abilities" }
          ],
          nbChoices: 2
        }
      ],
      20: [
        {
          name: "Second Wind",
          desc: "Twice per short or long rest, the sidekick can use a bonus action on its turn to regain hit points equal to 1d10 + its level in this class.",
          category: "bonus_actions"
        }
      ]
    };
  }
};

// modals/modals.ts
var LevelSelectModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, onSelect) {
    super(app);
    this.onSelect = onSelect;
    this.setPlaceholder("Select level");
  }
  getItems() {
    return Array.from({ length: 20 }, (_, i) => i + 1);
  }
  getItemText(item) {
    return `${item}`;
  }
  onChooseItem(item, evt) {
    this.onSelect(item);
  }
};
var ClassSelectModal = class extends import_obsidian.SuggestModal {
  constructor(app, onClassChosen) {
    super(app);
    this.onClassChosen = onClassChosen;
    this.setPlaceholder("Select class");
    this.classes = [
      new Expert(),
      new Spellcaster(),
      new Warrior()
    ];
  }
  getSuggestions(query) {
    return this.classes.filter((cls) => cls.name.toLowerCase().includes(query.toLowerCase()));
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: item.name, cls: "suggestion-name" });
    el.createEl("small", { text: item.desc, cls: "suggestion-desc" });
  }
  onChooseSuggestion(item, evt) {
    this.onClassChosen(item);
  }
};
var OptionSelectModal = class extends import_obsidian.SuggestModal {
  constructor(app, feature, resolve, choiceIndex, maxChoices) {
    super(app);
    this.feature = feature;
    this.resolve = resolve;
    this.setPlaceholder(`Select ${this.feature.name.toLowerCase()} (${choiceIndex + 1}/${maxChoices})`);
  }
  getSuggestions(query) {
    if (!this.feature.options)
      return [];
    const lowerCaseQuery = query.toLowerCase();
    return this.feature.options.filter(
      (option) => option.name.toLowerCase().includes(lowerCaseQuery)
    );
  }
  renderSuggestion(item, el) {
    el.createEl("div", { text: item.name, cls: "suggestion-name" });
    el.createEl("small", { text: item.desc, cls: "suggestion-desc" });
  }
  onChooseSuggestion(item, evt) {
    this.resolve(item);
    this.close();
  }
};
var NameInputModal = class extends import_obsidian.Modal {
  constructor(app, resolve) {
    super(app);
    this.resolve = resolve;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h4", { text: "Enter a name for the sidekick" });
    const formContainer = contentEl.createEl("div", { cls: "form-container" });
    const nameInput = formContainer.createEl("input", {
      type: "text",
      placeholder: "Enter name...",
      cls: "form-input"
    });
    const submitButton = formContainer.createEl("button", {
      text: "Save",
      cls: "form-button"
    });
    submitButton.addEventListener("click", () => {
      this.resolve(nameInput.value);
      this.close();
    });
    nameInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        this.resolve(nameInput.value);
        this.close();
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var FolderSelectModal = class extends import_obsidian.FuzzySuggestModal {
  constructor(app, resolve) {
    super(app);
    this.resolve = resolve;
    this.setPlaceholder("Enter or select a folder...");
    this.setInstructions([
      { command: "/", purpose: "navigate to a folder" },
      { command: "<folder-name>", purpose: "select a folder" }
    ]);
  }
  getItems() {
    return this.app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian.TFolder).map((folder) => folder.path);
  }
  getItemText(item) {
    return item.split("/").pop() || item;
  }
  onChooseItem(item, _evt) {
    const folder = this.app.vault.getAbstractFileByPath(item);
    if (folder instanceof import_obsidian.TFolder) {
      this.resolve(folder.path);
    } else {
      this.resolve(void 0);
    }
    this.close();
  }
  onOpen() {
    super.onOpen();
    this.inputEl.focus();
  }
  onClose() {
    this.resolve(void 0);
    super.onClose();
  }
};

// modals/show.ts
function showLevelSelectModal(app) {
  return new Promise((resolve) => {
    const modal = new LevelSelectModal(app, resolve);
    modal.open();
  });
}
function showClassSelectModal(app) {
  return new Promise((resolve) => {
    const modal = new ClassSelectModal(app, resolve);
    modal.open();
  });
}
function showOptionSelectModal(app, feature, choiceIndex, maxChoices) {
  return new Promise((resolve) => {
    const modal = new OptionSelectModal(app, feature, resolve, choiceIndex, maxChoices);
    modal.open();
  });
}
function showNameInputModal(app) {
  return new Promise((resolve) => {
    const modal = new NameInputModal(app, resolve);
    modal.open();
  });
}
function showFolderSelectModal(app) {
  return new Promise((resolve) => {
    const modal = new FolderSelectModal(app, resolve);
    modal.open();
  });
}

// statblocks/statblocks.ts
var import_obsidian2 = require("obsidian");
function getAbilityForSkill(skill) {
  const skillToAbilityMap = {
    acrobatics: "dexterity",
    animal_handling: "wisdom",
    arcana: "intelligence",
    athletics: "strength",
    deception: "charisma",
    history: "intelligence",
    insight: "wisdom",
    intimidation: "charisma",
    investigation: "intelligence",
    medicine: "wisdom",
    nature: "intelligence",
    perception: "wisdom",
    performance: "charisma",
    persuasion: "charisma",
    religion: "intelligence",
    sleight_of_hand: "dexterity",
    stealth: "dexterity",
    survival: "wisdom"
  };
  const normalizedSkill = skill.toLowerCase().replace(/ /g, "_");
  if (skillToAbilityMap[normalizedSkill]) {
    return skillToAbilityMap[normalizedSkill];
  } else {
    throw new Error(`Ability not found for skill: ${skill}`);
  }
}
var Statblock = class {
  constructor(data) {
    Object.assign(this, data);
  }
};
function extractStatblock(noteContent) {
  const regex = /```statblock\n([\s\S]+?)\n```/;
  const match = noteContent.match(regex);
  if (match && match[1]) {
    try {
      const data = (0, import_obsidian2.parseYaml)(match[1]);
      return new Statblock(data);
    } catch (e) {
      console.error("Failed to parse YAML:", e);
      return null;
    }
  } else {
    console.error("No statblock found");
    return null;
  }
}
function formatStatblockAsText(statblock) {
  const yamlContent = (0, import_obsidian2.stringifyYaml)(statblock);
  return `
\`\`\`statblock
${yamlContent}
\`\`\``;
}
async function saveStatblockToFile(plugin, content, name) {
  const { settings } = plugin;
  let folderPath;
  switch (settings.saveMode) {
    case "sameFolder":
      folderPath = this.app.workspace.getActiveFile().parent.path;
      break;
    case "defaultFolder":
      folderPath = (0, import_obsidian2.normalizePath)(settings.saveFolder);
      break;
    case "promptFolder":
      const Folder = await showFolderSelectModal(plugin.app);
      if (!Folder) {
        return;
      }
      folderPath = Folder;
      break;
    default:
      new import_obsidian2.Notice("Invalid save mode setting.");
      return;
  }
  try {
    const exists = await plugin.app.vault.adapter.exists(folderPath);
    if (!exists) {
      await plugin.app.vault.createFolder(folderPath);
    }
    let fileName = `${name}`;
    const filePath = `${folderPath}/${fileName}`;
    const fileExists = await plugin.app.vault.adapter.exists(filePath);
    if (fileExists) {
      let newFileName;
      while (true) {
        const modalResult = await showNameInputModal(plugin.app);
        if (typeof modalResult === "string") {
          newFileName = modalResult;
        } else {
          return;
        }
        if (!newFileName) {
          return;
        }
        fileName = `${newFileName}.md`;
        const newFilePath = `${folderPath}/${fileName}`;
        const newFileExists = await plugin.app.vault.adapter.exists(newFilePath);
        if (!newFileExists) {
          name = newFileName;
          break;
        } else {
          new import_obsidian2.Notice(`File ${newFileName}.md already exists. Please choose a different name.`);
        }
      }
    }
    await plugin.app.vault.create(filePath, content);
    plugin.app.workspace.openLinkText(fileName, filePath, true, { active: true });
  } catch (error) {
    console.error("Failed to save the file:", error);
    new import_obsidian2.Notice("Error saving the sidekick");
  }
}

// sidekicks/sidekicks.ts
var Sidekick = class {
  constructor(statblock, sidekickClass, level) {
    this.statblock = statblock;
    this.sidekickClass = sidekickClass;
    this.level = level;
  }
  // reimplementation with Attack class
  checkCondition(condition) {
    switch (condition) {
      case "humanoid":
        if (!this.statblock.type) {
          return false;
        } else
          return this.statblock.type.toLowerCase().includes("humanoid");
      case "simple weapon":
        if (!this.statblock.actions) {
          return false;
        }
        const simpleAttacks = this.statblock.actions.map((action) => new Attack(action)).filter((attack) => attack.isAttack && attack.isSimpleWeapon);
        return simpleAttacks.length > 0;
      case "martial weapon":
        if (!this.statblock.actions) {
          return false;
        }
        const martialAttacks = this.statblock.actions.map((action) => new Attack(action)).filter((attack) => attack.isAttack && attack.isMartialWeapon);
        return martialAttacks.length > 0;
      default:
        return false;
    }
  }
  getOptions(feature) {
    var _a;
    if (!feature.options) {
      return [];
    }
    switch (feature.name) {
      case "Saving Throw Proficiency":
        if (this.statblock && this.statblock.saves) {
          let existingSaves;
          if (Array.isArray(this.statblock.saves)) {
            existingSaves = this.statblock.saves.map((save) => Object.keys(save)[0]);
          } else {
            existingSaves = Object.keys(this.statblock.saves);
          }
          return feature.options.filter(
            (option) => !existingSaves.includes(option.name)
          );
        }
        return feature.options;
      case "Skill Proficiencies":
        if (this.statblock && this.statblock.skillsaves) {
          let existingSkills;
          if (Array.isArray(this.statblock.skillsaves)) {
            existingSkills = this.statblock.skillsaves.map((skill) => Object.keys(skill)[0]);
          } else {
            existingSkills = Object.keys(this.statblock.skillsaves);
          }
          return feature.options.filter(
            (option) => !existingSkills.includes(option.name)
          );
        }
        return feature.options;
      case "Tool Proficiencies":
        if (this.statblock && this.statblock.traits) {
          const existingProfString = (_a = this.statblock.traits.find(
            (trait) => trait.name === "Equipment Proficiencies"
          )) == null ? void 0 : _a.desc.split("with")[1].slice(0, -1);
          ;
          const existingProfList = existingProfString ? existingProfString.split(", ") : [];
          return feature.options.filter(
            (option) => !existingProfList.includes(option.name)
          );
        }
        return feature.options;
      case "Expertise":
        const existingExpertiseSkills = new Set(this.expertiseSkills || []);
        if (this.statblock.skillsaves) {
          return Object.keys(this.statblock.skillsaves).filter((skill) => !existingExpertiseSkills.has(skill)).map((skill) => ({ name: skill }));
        }
        return [];
      case "Ability Score Improvement":
        const abilities = Abilities.fromArray(this.statblock.stats);
        feature.options = [];
        for (const [key, value] of Object.entries(abilities)) {
          if (value < 20) {
            const abilityName = key.charAt(0).toUpperCase() + key.slice(1);
            const abilityMod = Abilities.calculateModifier(value);
            const modSign = abilityMod >= 0 ? "+" : "-";
            feature.options.push({
              name: abilityName,
              desc: `${value} (${modSign}${Math.abs(abilityMod)})`
            });
          }
        }
        return feature.options;
      default:
        return feature.options;
    }
  }
  // Method to apply features to the statblock
  applyFeature(feature, choice) {
    const proficiencyBonus = Proficiency.calculatePB(this.level);
    const abilities = Abilities.fromArray(this.statblock.stats);
    switch (feature.name) {
      case "Saving Throw Proficiency":
      case "Sharp Mind":
        if (choice) {
          if (!this.statblock.saves) {
            this.statblock.saves = {};
          }
          const abilityKey = choice.name.toLowerCase();
          this.statblock.saves[abilityKey] = 0;
        }
        break;
      case "Skill Proficiencies":
        if (choice) {
          if (!this.statblock.skillsaves) {
            this.statblock.skillsaves = {};
          }
          this.statblock.skillsaves[choice.name] = 0;
        }
        break;
      case "Tool Proficiencies":
      case "Armor Proficiency":
      case "Shield Proficiency":
      case "Weapon Proficiency":
        let equipment = "";
        if (choice) {
          equipment = choice.name;
        } else {
          equipment = feature.desc;
        }
        if (this.statblock && this.statblock.traits) {
          const existingEquipmentProficiencies = this.statblock.traits.find(
            (trait) => trait.name === "Equipment Proficiencies"
          );
          if (existingEquipmentProficiencies) {
            existingEquipmentProficiencies.desc = existingEquipmentProficiencies.desc.replace(".", ", ");
            existingEquipmentProficiencies.desc += `${equipment}.`;
          } else {
            this.statblock.traits.push({
              name: "Equipment Proficiencies",
              desc: `The sidekick has proficiency with ${equipment}.`
            });
          }
        }
        break;
      case "Expertise":
        if (choice) {
          if (!this.expertiseSkills) {
            this.expertiseSkills = [];
          }
          this.expertiseSkills.push(choice.name);
        }
        break;
      case "Ability Score Improvement":
        if (choice) {
          const abilityName = choice.name.toLowerCase();
          const abilities2 = new Abilities(...this.statblock.stats);
          const index = Object.keys(abilities2).indexOf(abilityName);
          this.statblock.stats[index] = abilities2[abilityName] += 1;
        }
        break;
      case "Martial Role":
        if (!choice) {
          return;
        }
        feature.name = choice.name;
        feature.desc = choice.desc || "";
        feature.category = choice.category;
        if (choice.name === "Attacker") {
          const actions = this.statblock.actions;
          if (!actions)
            return;
          this.statblock.actions = actions.map((action) => {
            const attack = new Attack(action);
            if (attack.isAttack && attack.toHit !== void 0) {
              attack.toHit += 2;
              return {
                ...action,
                desc: attack.constructDescription()
              };
            }
            return action;
          });
        }
        ;
        this.applyStandardFeature(feature);
        break;
      case "Spellcaster Role":
        if (choice) {
          if (this.statblock.traits) {
            this.statblock.traits = this.statblock.traits.filter(
              (trait) => trait.name.toLowerCase() !== "spells" && trait.name.toLowerCase() !== "spellcasting"
            );
          }
          feature.name = choice.name;
          feature.desc = "";
        }
        ;
        this.applyStandardFeature(feature);
        break;
      case "School of Magic for Empowered Spells":
        if (choice) {
          feature.name = "Empowered Spells";
          feature.desc = `Whenever the sidekick casts a spell in the ${choice.name} school by expending a spell slot, the sidekick can add its spellcasting ability modifier to the spell's damage roll or healing roll, if any.`;
          this.applyStandardFeature(feature);
        }
        break;
      case "Improved Defense":
        let ac = this.statblock.ac;
        console.log(ac);
        if (typeof ac === "string") {
          const acParts = ac.split(" ", 2);
          acParts[0] += 1;
          ac = `${acParts[0]} ${acParts[1]}`;
        }
        if (typeof ac === "number") {
          ac += 1;
        }
        console.log(ac);
        this.statblock.ac = ac;
      default:
        this.applyStandardFeature(feature);
        break;
    }
  }
  applyStandardFeature(feature) {
    const validCategories = ["traits", "actions", "bonus_actions", "legendary_actions", "mythic_actions", "reactions"];
    function isValidCategory(category2) {
      return validCategories.includes(category2);
    }
    const category = feature.category && isValidCategory(feature.category) ? feature.category : "traits";
    if (!this.statblock[category]) {
      this.statblock[category] = [];
    }
    const index = this.statblock[category].findIndex((trait) => trait.name === feature.name);
    const newTrait = {
      name: feature.name,
      desc: feature.desc
    };
    if (index !== -1) {
      this.statblock[category][index] = newTrait;
    } else {
      this.statblock[category].push(newTrait);
    }
  }
  applySpellcasting() {
    const proficiencyBonus = Proficiency.calculatePB(this.level);
    let spellList = "";
    let spellAbility = "";
    if (this.statblock.traits) {
      const role = this.statblock.traits.find((trait) => ["Healer", "Mage", "Prodigy"].includes(trait.name));
      if (!role) {
        return;
      }
      switch (role.name) {
        case "Mage":
          spellList = "Wizard";
          spellAbility = "Intelligence";
          break;
        case "Healer":
          spellList = "Cleric and Druid";
          spellAbility = "Wisdom";
          break;
        case "Prodigy":
          spellList = "Bard and Warlock";
          spellAbility = "Charisma";
          break;
      }
      const abilities = Abilities.fromArray(this.statblock.stats);
      const abilityName = spellAbility.toLowerCase();
      const spellMod = Abilities.calculateModifier(abilities[abilityName]);
      const spellDC = 8 + proficiencyBonus + spellMod;
      const spellAttack = proficiencyBonus + spellMod;
      const spellAttackSign = spellAttack >= 0 ? "+" : "-";
      const spellAttackWithSign = `${spellAttackSign}${Math.abs(spellAttack)}`;
      const spellcasterLevel = this.level;
      const spellSlots = {
        1: 0,
        2: 0,
        3: 0,
        4: 0,
        5: 0
      };
      const spellTable = [
        { level: 1, cantrips: 2, spells: 1, slots: { 1: 2 } },
        { level: 2, cantrips: 2, spells: 2, slots: { 1: 2 } },
        { level: 3, cantrips: 2, spells: 3, slots: { 1: 3 } },
        { level: 4, cantrips: 3, spells: 3, slots: { 1: 3 } },
        { level: 5, cantrips: 3, spells: 4, slots: { 1: 4, 2: 2 } },
        { level: 6, cantrips: 3, spells: 4, slots: { 1: 4, 2: 2 } },
        { level: 7, cantrips: 3, spells: 5, slots: { 1: 4, 2: 3 } },
        { level: 8, cantrips: 3, spells: 5, slots: { 1: 4, 2: 3 } },
        { level: 9, cantrips: 3, spells: 6, slots: { 1: 4, 2: 3, 3: 2 } },
        { level: 10, cantrips: 4, spells: 6, slots: { 1: 4, 2: 3, 3: 2 } },
        { level: 11, cantrips: 4, spells: 7, slots: { 1: 4, 2: 3, 3: 3 } },
        { level: 12, cantrips: 4, spells: 7, slots: { 1: 4, 2: 3, 3: 3 } },
        { level: 13, cantrips: 4, spells: 8, slots: { 1: 4, 2: 3, 3: 3, 4: 1 } },
        { level: 14, cantrips: 4, spells: 8, slots: { 1: 4, 2: 3, 3: 3, 4: 1 } },
        { level: 15, cantrips: 4, spells: 9, slots: { 1: 4, 2: 3, 3: 3, 4: 2 } },
        { level: 16, cantrips: 4, spells: 9, slots: { 1: 4, 2: 3, 3: 3, 4: 2 } },
        { level: 17, cantrips: 4, spells: 10, slots: { 1: 4, 2: 3, 3: 3, 4: 3, 5: 1 } },
        { level: 18, cantrips: 4, spells: 10, slots: { 1: 4, 2: 3, 3: 3, 4: 3, 5: 1 } },
        { level: 19, cantrips: 4, spells: 11, slots: { 1: 4, 2: 3, 3: 3, 4: 3, 5: 2 } },
        { level: 20, cantrips: 4, spells: 11, slots: { 1: 4, 2: 3, 3: 3, 4: 3, 5: 2 } }
      ];
      const levelData = spellTable.find((entry) => entry.level === spellcasterLevel);
      if (levelData) {
        const cantripsKnown = levelData.cantrips;
        const spellsKnown = levelData.spells;
        for (const [level, slots] of Object.entries(levelData.slots)) {
          spellSlots[level] = slots;
        }
        const spellcasting = `The sidekick is a level ${spellcasterLevel} spellcaster. Its spellcasting ability is ${spellAbility} (spell save DC ${spellDC}, ${spellAttackWithSign} to hit with spell attacks). The sidekick can cast the following ${cantripsKnown} cantrips and ${spellsKnown} spells from the ${spellList} spell list${spellList.includes("and") ? "s" : ""}:
- Cantrips (at will): 
` + Object.entries(spellSlots).filter(([_, value]) => value > 0).map(([level, slots]) => `- Level ${level} (${slots} slot${slots !== 1 ? "s" : ""}): 
`).join("");
        role.desc = spellcasting;
      } else {
        role.desc = "";
      }
    }
  }
  updateSkills(oldAbilities, oldProficiencyBonus) {
    var _a;
    const newAbilities = Abilities.fromArray(this.statblock.stats);
    const oldMods = Abilities.calculateModifiers(oldAbilities);
    const newMods = Abilities.calculateModifiers(newAbilities);
    const newProficiencyBonus = Proficiency.calculatePB(this.level);
    const updatedSkills = {};
    for (const skill in this.statblock.skillsaves) {
      const skillAbility = getAbilityForSkill(skill);
      const oldAbilityMod = oldMods[skillAbility];
      const newAbilityMod = newMods[skillAbility];
      const isExpertise = ((_a = this.expertiseSkills) == null ? void 0 : _a.includes(skill)) || false;
      let oldSkillBonus = this.statblock.skillsaves[skill];
      if (oldSkillBonus === 0) {
        oldSkillBonus = oldAbilityMod + oldProficiencyBonus;
      }
      const newProficiencyBonusToAdd = isExpertise ? newProficiencyBonus * 2 : newProficiencyBonus;
      const newSkillBonus = oldSkillBonus - oldAbilityMod - oldProficiencyBonus + newAbilityMod + newProficiencyBonusToAdd;
      updatedSkills[skill] = newSkillBonus;
    }
    const sortedSkills = Object.entries(updatedSkills).sort((a, b) => a[0].localeCompare(b[0])).reduce((obj, [key, value]) => {
      obj[key] = value;
      return obj;
    }, {});
    this.statblock.skillsaves = sortedSkills;
  }
  updateSaves(oldAbilities, oldProficiencyBonus) {
    const newAbilities = Abilities.fromArray(this.statblock.stats);
    const oldMods = Abilities.calculateModifiers(oldAbilities);
    const newMods = Abilities.calculateModifiers(newAbilities);
    const newProficiencyBonus = Proficiency.calculatePB(this.level);
    const updatedSaves = {};
    for (const save in this.statblock.saves) {
      const saveKey = save.toLowerCase();
      const oldAbilityMod = oldMods[saveKey];
      const newAbilityMod = newMods[saveKey];
      let oldSaveBonus = this.statblock.saves[save];
      if (oldSaveBonus === void 0 || oldSaveBonus === 0) {
        oldSaveBonus = oldAbilityMod + oldProficiencyBonus;
      }
      const newSaveBonus = oldSaveBonus - oldAbilityMod - oldProficiencyBonus + newAbilityMod + newProficiencyBonus;
      updatedSaves[saveKey] = newSaveBonus;
    }
    const sortedSaves = Object.entries(updatedSaves).sort((a, b) => a[0].localeCompare(b[0])).reduce((obj, [key, value]) => {
      obj[key] = value;
      return obj;
    }, {});
    this.statblock.saves = sortedSaves;
  }
  updateAttacks(oldAbilities, oldProficiencyBonus) {
    var _a;
    const newAbilities = Abilities.fromArray(this.statblock.stats);
    const oldMods = Abilities.calculateModifiers(oldAbilities);
    const newMods = Abilities.calculateModifiers(newAbilities);
    const newProficiencyBonus = Proficiency.calculatePB(this.level);
    const actions = (_a = this.statblock.actions) != null ? _a : [];
    const updatedActions = [];
    for (const action of actions) {
      const attack = new Attack(action);
      if (attack.isAttack) {
        const relevantAbility = attack.getRelevantAbility(newAbilities);
        const oldAbilityMod = oldMods[relevantAbility];
        const newAbilityMod = newMods[relevantAbility];
        const proficiencyBonusDiff = newProficiencyBonus - oldProficiencyBonus;
        const modifierDiff = newAbilityMod - oldAbilityMod;
        let updatedToHit = attack.toHit;
        let updatedDamageMod = attack.damageMod;
        if (attack.toHit !== void 0) {
          attack.toHit += modifierDiff;
          attack.toHit += proficiencyBonusDiff;
        }
        if (attack.damageMod !== void 0) {
          attack.damageMod += modifierDiff;
        }
        const updatedAction = {
          ...action,
          desc: attack.constructDescription()
        };
        if (this.statblock.actions) {
          this.statblock.actions[this.statblock.actions.indexOf(action)] = updatedAction;
        } else {
          this.statblock.actions = [updatedAction];
        }
      }
    }
    this.statblock.actions = updatedActions;
  }
  updateSenses() {
    const senses = this.statblock.senses;
    if (!senses)
      return;
    const passivePerceptionMatch = senses.match(/passive Perception (\d+)/i);
    if (passivePerceptionMatch) {
      const currentPassivePerception = parseInt(passivePerceptionMatch[1], 10);
      const abilities = Abilities.fromArray(this.statblock.stats);
      const wisdomMod = Abilities.calculateModifier(abilities.wisdom);
      const proficiencyBonus = Proficiency.calculatePB(this.level);
      let perception = 10;
      if (this.statblock.skillsaves && this.statblock.skillsaves.hasOwnProperty("Perception")) {
        perception += wisdomMod + proficiencyBonus;
      } else {
        perception += wisdomMod;
      }
      const newPassivePerception = perception;
      if (newPassivePerception !== currentPassivePerception) {
        this.statblock.senses = senses.replace(/passive Perception \d+/i, `passive Perception ${newPassivePerception}`);
      }
    }
  }
  /**
   * Serialize the sidekick to a string format for saving or debugging.
   */
  toString() {
    return `Sidekick: ${this.statblock.name}, Class: ${this.sidekickClass.name}, Level: ${this.level}`;
  }
};

// settings/settings.ts
var import_obsidian3 = require("obsidian");
var DEFAULT_SETTINGS = {
  saveFolder: "/sidekicks",
  saveMode: "defaultFolder"
  // Set the default save mode
};
var StatblockSidekickSettingsTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Save mode").setDesc("Choose how to save the sidekick files").addDropdown(
      (dropdown) => dropdown.addOption("sameFolder", "Same as original file").addOption("defaultFolder", "Default folder").setValue(this.plugin.settings.saveMode).onChange(async (value) => {
        this.plugin.settings.saveMode = value;
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian3.Setting(containerEl).setName("Default folder").setDesc("Select the folder where sidekick files should be saved when 'Save mode' is set to 'Default folder'").addText((textComponent) => {
      textComponent.inputEl.placeholder = "Enter folder path...";
      textComponent.setValue(this.plugin.settings.saveFolder);
      textComponent.onChange(async (value) => {
        this.plugin.settings.saveFolder = value;
        await this.plugin.saveSettings();
      });
    });
  }
};

// main.ts
var StatblockSidekick = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.initializeSettings();
    this.addCommand({
      id: "create-sidekick",
      name: "Create sidekick",
      checkCallback: (checking) => {
        const markdownView = this.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
        if (markdownView) {
          if (!checking) {
            const text = markdownView.editor.getValue();
            this.createSidekick(text);
          }
          return true;
        }
        return false;
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  initializeSettings() {
    this.addSettingTab(new StatblockSidekickSettingsTab(this.app, this));
  }
  async createSidekick(text) {
    const statblock = extractStatblock(text);
    if (!statblock) {
      new import_obsidian4.Notice("No valid statblock found!");
      return;
    }
    const cr = ChallengeRating.parse(statblock.cr);
    if (!cr) {
      new import_obsidian4.Notice(`CR ${statblock.cr} is invalid!`);
      return;
    } else if (!cr.isSuitable()) {
      new import_obsidian4.Notice("CR must be \u2264 1/2");
      return;
    }
    const hitDice = HitDice.parse(statblock.hit_dice);
    if (!hitDice) {
      return;
    }
    const sidekickClass = await showClassSelectModal(this.app);
    if (!sidekickClass) {
      return;
    }
    const level = await showLevelSelectModal(this.app);
    if (level === void 0) {
      return;
    }
    const oldAbilities = Abilities.fromArray(statblock.stats);
    const oldMods = Abilities.calculateModifiers(oldAbilities);
    const oldProficiencyBonus = 2;
    const sidekick = new Sidekick(statblock, sidekickClass, level);
    for (let levelIndex = 0; levelIndex < level; levelIndex++) {
      const abilities2 = Abilities.fromArray(statblock.stats);
      const conMod = Abilities.calculateModifier(abilities2.constitution);
      hitDice.increment(conMod);
      const features = sidekickClass.featuresByLevel[levelIndex + 1];
      if (features) {
        let levelNotice = new import_obsidian4.Notice(`Level ${levelIndex + 1}...`, 0);
        for (const feature of features) {
          const shouldApplyFeature = !feature.conditions || feature.conditions.some((condition) => sidekick.checkCondition(condition));
          if (shouldApplyFeature) {
            if (feature.options) {
              for (let choiceIndex = 0; choiceIndex < (feature.nbChoices || 1); choiceIndex++) {
                feature.options = sidekick.getOptions(feature);
                const selectedOption = await showOptionSelectModal(this.app, feature, choiceIndex, feature.nbChoices || 1);
                sidekick.applyFeature(feature, selectedOption);
              }
            } else {
              sidekick.applyFeature(feature);
            }
          }
        }
        levelNotice.hide();
      } else {
      }
    }
    sidekick.applySpellcasting();
    const proficiencyBonus = Proficiency.calculatePB(sidekick.level);
    const proficiencyDiff = proficiencyBonus - oldProficiencyBonus;
    const abilities = Abilities.fromArray(statblock.stats);
    const mods = Abilities.calculateModifiers(abilities);
    const modDiff = Abilities.calculateModDiff(oldMods, mods);
    sidekick.updateSkills(oldAbilities, oldProficiencyBonus);
    sidekick.updateAttacks(oldAbilities, oldProficiencyBonus);
    sidekick.updateSaves(oldAbilities, oldProficiencyBonus);
    sidekick.updateSenses();
    sidekick.statblock.hit_dice = hitDice.toString();
    sidekick.statblock.cr = sidekick.level;
    const sidekickName = await showNameInputModal(this.app);
    sidekick.statblock.name = `${sidekickName} - ${sidekick.statblock.name} - ${sidekick.sidekickClass.name} Sidekick`;
    const fileName = `${sidekick.statblock.name}.md`;
    const updatedContent = formatStatblockAsText(sidekick.statblock);
    saveStatblockToFile(this, updatedContent, fileName);
  }
  onunload() {
  }
};


/* nosourcemap */